<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>Process Menu</title><link rel="stylesheet" type="text/css" href="Process%20Menu_files/ij.css"><link rel="shortcut icon" href="http://rsb.info.nih.gov/ij/favicon.ico"></head><body bgcolor="#ffffff">

<p class="navbar"> <a href="https://imagej.nih.gov/ij/index.html">home</a> | <a href="https://imagej.nih.gov/ij/docs/index.html">contents</a> | <a href="https://imagej.nih.gov/ij/docs/menus/image.html">previous</a> | <a href="https://imagej.nih.gov/ij/docs/menus/analyze.html">next</a></p>
<h1>Process Menu</h1>

<blockquote>

<ul>
<li><a href="#smooth">Smooth</a>
</li><li><a href="#sharpen">Sharpen</a>
</li><li><a href="#find">Find Edges</a>
</li><li><a href="#find-maxima">Find Maxima</a>
</li><li><a href="#enhance">Enhance Contrast</a>
</li><li><a href="#noise">Noise&gt;</a>
</li><li><a href="#shadows">Shadows&gt;</a>
</li><li><a href="#binary">Binary&gt;</a>
</li><li><a href="#math">Math&gt;</a>
</li><li><a href="#fft">FFT&gt;</a>
</li><li><a href="#filters">Filters&gt;</a>
</li><li><a href="#calculator">Image Calculator...</a>
</li><li><a href="#background">Subtract Background...</a>
</li><li><a href="#repeat">Repeat Command</a>
</li></ul>

<a name="smooth"></a>
<h3>Smooth</h3>
Blurs the active image or selection. This filter replaces each pixel with the average of its 3x3 neighborhood.

<a name="sharpen"></a>

<h3>Sharpen</h3>
Increases contrast and accentuates detail in the image or selection, but
 may also accentuate noise. This filter uses the following weighting 
factors to replace each pixel with a weighted average of the 3x3 
neighborhood.

<pre>    -1 -1 -1
    -1 12 -1
    -1 -1 -1
</pre>

<a name="find"></a>

<h3>Find Edges</h3>
Uses a Sobel edge detector to highlight sharp changes in intensity in 
the active image or selection. Two 3x3 convolution kernels (show below) 
are used to generate vertical and horizontal derivatives. The final 
image is produced by combining the two derivatives using the square root
 of the sum of the squares. 

<pre>     1  2  1     1  0 -1
     0  0  0     2  0 -2
    -1 -2 -1     1  0 -1
</pre>

<a name="find-maxima"></a>
<h3>Find Maxima...</h3>
Determines the local maxima in an image and creates a binary (mask-like) image of the same size 
with the maxima, or one segmented particle per maximum, marked.
For RGB images, maxima of luminance are selected, with the luminance defined as weighted or 
unweighted average of the colors depending on the <i>Edit&gt;Options&gt;Conversions</i> settings. This
command is based on a plugin contributed by Michael Schmid.

<p></p><center><img src="Process%20Menu_files/find-maxima.jpg" alt="[Dialog Box]" width="661" height="243"></center><p>

A dialog box is displayed with the following options:
</p><ul>
<li><i>"Noise Tolerance"</i> - Maxima are ignored if they do not stand out from the surroundings by more than this value
(calibrated units for calibrated images).
In other words, a threshold is set at the maximum value minus noise tolerance and the 
contiguous area around the maximum above the threshold is analyzed. For accepting a maximum, this area must not contain 
any point with a value higher at than the maximum. Only one maximum within this area is accepted.
</li><li><i>"Output Type" </i>can be:
   <ul>
   <li><i>"Single Points"</i> - results in one single point per maximum
   </li><li><i>"Maxima Within Tolerance"</i> - all points within the "Noise Tolerance" for each maximum
   </li><li><i>"Segmented Particles"</i> - Assumes that each maximum belongs to a particle and segments 
     the image by a watershed algorithm applied to the values of the image (in contrast to  
     <i>Process&gt;Binary&gt;Watershed</i>, which uses the Euclidian distance map).
   </li><li><i>"Display Point selection"</i> - Displays a multi-point selection with a point at each maximum
   </li><li><i>"Count"</i> - Displays the number of maxima in the Results window
   </li></ul>
</li><li><i>"Exclude Edge Maxima"</i> - Excludes maxima if the area within the noise tolerance surrounding a maximum touches 
the edge of the image (edge of the selection does not matter).
</li><li> Check <i>Light Background </i> if the image background is brighter than the objects you want to find, 
as it is in the Cell&nbsp;Colony image in the illustration above.
</li><li><i>"Above Lower Threshold"</i> - (This option appears for thresholded images only.)
Finds maxima above the lower threshold only. The upper threshold of the image is ignored. 
If "Segmented Particles" is selected as 
"Output Type", the area below the lower threshold is considered a background.
</li></ul>

<p></p><center><img src="Process%20Menu_files/find-maxima2.jpg" alt="[Examples]" width="622" height="221"></center><p>

Output is a binary image, with foreground 255 and background 0, using an inverted or normal LUT depending on 
the "Black Background" option in <i>Process&gt;Binary&gt;Options</i>. 
The number of particles (as obtained by "Analyze Particles") 
in the output image does not depend on the "Output Type" selected. Note 
that "Segmented Particles" will usually result in 
particles touching the edge if "Exclude Edge Maxima" is selected. 
"Exclude Edge Maxima" applies to the maximum, not to the particle.
</p><p>

<i>Find Maxima</i> does not work on stacks, but the
<a href="http://rsbweb.nih.gov/ij/macros/FindStackMaxima.txt">FindStackMaxima</a>
macro runs it on all the images in a stack and creates a second stack containing the output images.
The <a href="http://rsbweb.nih.gov/ij/macros/examples/FindMaximaRoiManager.txt">FindMaximaRoiManager</a>
macro demonstrates how to add particles found by <i>Find Maxima</i> to the <i>ROI Manager</i>.

<a name="enhance"></a>

</p><h3>Enhance Contrast</h3>
Enhances image contrast by using either histogram stretching or histogram equalization.
Both methods are described in detail in the 
<a href="http://www.dai.ed.ac.uk/HIPR2/">Hypermedia Image Processing Reference</a>. 
Look up "enhancement" in the 
<a href="http://www.dai.ed.ac.uk/HIPR2/index.htm">index</a>.
<p>
This command does not alter pixel values as long as the <i>Normalize</i> and 
<i>Equalize histogram</i> options are not enabled.

</p><p></p><center><img src="Process%20Menu_files/enhance-contrast.png" alt="[Dialog]" width="245" height="198"></center><p>

<i>Saturated pixels</i> determines the number of pixels in the image that are allowed 
to become saturated.  Increasing this value increases contrast. This value should be greater than
zero to prevent a few outlying pixel from causing the histogram stretch to not work as intended.
</p><p>
Check <i>Normalize</i> and ImageJ will recalculate the pixel values of the image so
the range is equal to the maximum range for the data type, or 0-1.0 for float images.
The maximum range is 0-255 for 8-bit images and 0-65535 for 16-bit images. 
Note that normalization of RGB images is not supported. The <i>Use stack histogram</i>
option is ignored.
</p><p>With stacks another checkbox,
<i>Process all slices</i>, is displayed. If this option is enabled, normalization and
histogram equalization are applied to all slices in the stack. 
</p><p>
Check <i>Equalize histogram</i> to enhance the image using histogram equalization.
Create a selection and  the equalization will be based on the histogram of the selection. Uses a 
modified algorithm that takes the square root of the histogram  values. 
Hold the alt key down to use the standard histogram equalization algorithm.
The <i>Saturated pixels</i> and <i>Normalize</i> options are ignored when 
<i>Equalize Histogram</i> is checked. The equalization code was contributed 
by Richard Kirk.
</p><p>
If <i>Stack histogram</i> checked, ImageJ will use the overall stack histogram instead of
individual slice histograms, that allow optimal adjustments for each slice alone. This option
may be especially relevant when performing enhancements based on a ROI.


<a name="noise"></a>
</p><h2>Noise Submenu</h2>
Use the commands in this submenu to add noise to images or remove it. For more advanced capabilities,
check out Erik Meijering's RandomJ package (Binomial, Exponential, Gamma, Gaussian, Poisson and Uniform) at
<a href="http://www.imagescience.org/meijering/software/randomj/">
www.imagescience.org/meijering/software/randomj/</a>.


<p></p><center><img src="Process%20Menu_files/noise.gif" alt="[noise]"></center><p>

</p><blockquote>
<h3>Add Noise</h3>
Adds random noise to the image or selection. The noise is Gaussian 
(normally) distributed with a mean of zero and standard deviation of 25.

<h3>Add More Noise</h3>
Adds Gaussian noise with a mean of zero and standard deviation of 75.

<h3>Salt and Pepper</h3>
Adds salt and pepper noise to the image or selection by randomly 
replacing 2.5% of the pixels with black pixels and 2.5% with white 
pixels. Note: this command only works with 8-bit images.

<h3>Despeckle</h3>
This is a median filter. It replaces each pixel with the median value in its 3 x 3 neighborhood. 
This is a time consuming operation because, for each pixel in the selection, the nine pixels in the 
3x3 neighborhood must be sorted and the center pixel replaced with the median value (the fifth). 
Median filters a good at removing salt and pepper noise.

<a name="outliers"></a>
<h3>Remove Outliers</h3>
Replaces a pixel by the median of the pixels in the surrounding if it
deviates from the median by more than a certain value (the threshold).
Useful for correcting, e.g., hot pixels or dead pixels of a CCD image.

<p></p><center><img src="Process%20Menu_files/outliers.gif" alt="[Dialog]" width="255" height="204"></center>

<i>Radius</i> determines the area used for calculating the median
(uncalibrated, i.e., in pixels). See <i>Process&gt;Filters&gt;Show Circular Masks</i>
to see how radius translates into an area.
<i>Threshold</i> determinates by how much the pixel must deviate from the median to get
replaced, in raw (uncalibrated) units.
<i>Which Outliers </i> determines whether pixels brighter or darker than the
surrounding (the median) should be replaced.

<a name="nans"></a>
<h3>Remove NaNs</h3>
This filter replaces NaN (Not-a-Number) pixels in 32-bit (float) images by the median of the neighbors
inside the kernel area. It does not remove patches of NaNs larger than the kernel size, however.

<p></p><center><img src="Process%20Menu_files/remove-nans.png" alt="[Dialog]" width="247" height="148"></center>

<i>Radius</i> determines the area of the circular kernel used for calculating the median.
The <a href="https://imagej.nih.gov/ij/macros/examples/NaNs.txt">NaNs</a> macro demonstrates how to create, count and
remove NaNs.
Note that some ImageJ filters, such as <i>Gaussian Blur</i>, <i>Mean</i>, and
<i>Variance</i> destroy the surrounding of NaN pixel by setting it also to NaN.
Other filters may produce invalid results in the position of NaN pixels.

</blockquote>

<a name="shadows"></a>
<h2>Shadows Submenu</h2>
Commands in this submenu produce a shadow effect, with light appearing 
to come from a direction corresponding to the command name. The commands
 use <i>Convolve3x3</i>, ImageJ's 3x3 convolution function. Two of the convolution kernels are shown in the illustration. <i>Shadows Demo</i> uses all eight kernels to demonstrate the speed of <i>Convolve3x3</i>.

<p></p><center><img src="Process%20Menu_files/shadows.gif" alt="[shadows]"></center><p>

<a name="binary"></a>
</p><h2>Binary Submenu</h2>
This submenu contains commands that create or process binary (black and white) images. 
They assume that objects are black and background is white
unless "Black Background" is checked in the <i>Process&gt;Binary&gt;Options</i> dialog box.
<p></p><center><img src="Process%20Menu_files/morph.gif" alt="Examples" width="480" height="132"></center><p>

</p><blockquote>

<h3>Make Binary</h3>
Converts an image to black and white. The threshold level is determined by analysing 
the histogram of the current selection, or of the entire image if there is no selection.
The algorithm used to calculate the threshold is described in the
<a href="https://imagej.nih.gov/ij/docs/faqs.html#auto">FAQs</a>.
If a threshold has been set using the <i>Image&gt;Adjust&gt;Threshold</i> tool, 
a dialog pops up that lets you specify which pixels are set to the background color 
and which to the foreground color, and whether the background is black and the foreground is white.
<p>
With stacks, all images in the stack are converted to binary using the calculated threshold of the currently
displayed slice. Use the 
<a href="http://rsb.info.nih.gov/ij/macros/ConvertStackToBinary.txt">ConvertStackToBinary</a>
macro to convert a stack to binary using locally calculated thresholds. The
<a href="http://rsb.info.nih.gov/ij/macros/MakeSliceBinary.txt">MakeSliceBinary</a>
macro converts the current stack slice to binary and advances to the next when you press a key.

</p><h3>Convert to Mask</h3>
Converts the image to black and white based on the current threshold settings (if set) or on a threshold
calculated by analyzing the histogram.
The mask will have an inverting LUT (white is 0 and black is 255) unless "Black Background" is checked in 
the <i>Process&gt;Binary&gt;Options</i> dialog box.
 
<h3>Erode</h3>
Removes pixels from the edges of black objects. Use <i>Process&gt;Filters&gt;Minimum</i> to do grayscale erosion.

<h3>Dilate</h3>
Adds pixels to the edges of black objects.  Use <i>Process&gt;Filters&gt;Maximum</i> to do grayscale dilation.

<h3>Open</h3>
Performs an erosion operation, followed by dilation. This smoothes objects and removes isolated pixels.

<h3>Close</h3>
Performs a dilation operation, followed by erosion. This smoothes objects and fills in small holes.

<a name="options"></a>
<h3>Options...</h3>
Displays a dialog box that allows several settings used by commands in the 
<i>Binary</i> submenu to be altered.

<p></p><center><img src="Process%20Menu_files/binary-options.png" alt="Options Dialog" width="286" height="228"></center><br>

<i>Iterations</i> specifies the number of times erosion, dilation, opening, and closing are performed.
<p>
<i>Count</i> specifies the number of adjacent background pixels necessary before a pixel
is removed from the edge of an object during erosion and the number of adjacent foreground
 pixels necessary before a pixel is added to the edge of an object during dilation.
 </p><p>
Check <i>Black background</i> if the image has white objects on a black background.
Plugins can set this option using
</p><pre>    Prefs.blackBackground = <i>b</i>;
</pre>
and macros can set it using
<pre>    setOption("black background", <i>b</i>);
</pre>
where <i>b</i> is 'true' or 'false'.
<p>
If <i>Pad edges when eroding is checked</i>, <i>Process&gt;Binary&gt;Erode</i>
does not erode from the edges of the image. This setting also affects <i>Process&gt;Binary&gt;Close</i>,
which erodes from the edges unless this checkbox is selected.
</p><p>
<i>EDM output</i> determines the output type for the <i>Process&gt;Binary&gt;Distance Map</i>,
<i>Ultimate Points</i> and <i>Voronoi</i> commands. Set it to "Overwrite" for 8-bit output that
overwrites the input image; "8-bit", "16-bit" or "32-bit" for separate output images.
32-bit output has floating point (subpixel) distance resolution. 

</p><h3>Outline</h3>
Generates a one pixel wide outline of objects in a binary image.

<h3>Skeletonize</h3>
Repeatably removes pixels from the edges of objects in a binary image until they 
are reduced to single pixel wide skeletons.

<h3>Distance Map</h3>
Generates a Euclidian distance map (EDM). Each foreground pixel in the binary image 
is replaced with a gray value equal to that pixel's distance from the nearest background pixel. 


<h3>Ultimate Points</h3>
Generates the ultimate eroded points (UEPs) of the EDM. Requires a binary image as input. 
The UEPs represent the centers of particles that would be separated by segmentation. 
The UEP's gray value is equal to the radius of the inscribed circle of the corresponding particle. 


<a name="watershed"></a>
<h3>Watershed</h3>
Watershed segmentation is a way of automatically separating or cutting apart particles that touch. 
It first calculates the Euclidian distance map (EDM) and finds 
the ultimate eroded points (UEPs). It then dilates each of the UEPs (the peaks or local maxima of the EDM)
as far as possible - either until the edge of the particle is reached, or the edge of the region 
of another (growing) UEP. 
Watershed segmentation works best for smooth convex objects that don't overlap too much. 

<p></p><center><img src="Process%20Menu_files/watershed.gif" alt="watershed example" width="644" height="147"></center><p>

Enable debugging in <i>Edit&gt;Options&gt;Misc</i> and the Watershed command will 
create an animation that shows how the watershed algorithm works. An 
<a href="http://rsb.info.nih.gov/ij/images/watershed-animation.gif">example</a> is available.

<a name="voronoi"></a>
</p><h3>Voronoi</h3>
Splits the image by lines of points having equal distance to the
borders of the two nearest particles. Thus, the Voronoi cell of each particle
includes all points that are nearer to this particle than any other particle.
For the case of the particles being single points, this is a Voronoi tessellation
(also known as Dirichlet tessellation).
<p>
In the output, the value inside the Voronoi cells is zero; the pixel values
of the dividing lines between the cells are equal to the distance to the two
nearest particles. This is similar to a medial axis transform of the background,
but there are no lines in inner holes of particles. Choose the output type ("Overwrite", "8-bit", "16-bit" or "32-bit")
in the <i>Process&gt;Binary&gt;Options</i> dialog box.

</p><p></p><center><img src="Process%20Menu_files/voronoi.png" alt="voronoi example" width="628" height="211"></center><p>

</p></blockquote>

<a name="math"></a>
<h2>Math Submenu</h2>
The commands in this submenu add (subtract, multiply, etc.) a constant to each pixel in the active 
image or selection. When the result value overflows/underflows the legal range of the image's data
type, the value is reset to the maximum/minimum value. With stacks, a "Process Stack?"
dialog is displayed. This dialog has
<i>Yes</i> (process entire stack), <i>No</i> (process current image) and <i>Cancel</i> buttons. 


<blockquote>

<h3>Add...</h3>
Adds a constant to the image or selection. With 8-bit images, results greater than 255
are set to 255. With 16-bit signed images, results greater than 65,535 are set to 65,535.

<h3>Subtract...</h3>
Subtracts a constant from the image or selection. With 8-bit and 16-bit images, results
less than 0 are set to 0. 

<h3>Multiply...</h3>
Multiplies the image or selection by the specified real constant. With 8-bit images,
results greater than 255 are set to 255. With 16-bit signed images, results greater
than 65,535 are set to 65,535.

<h3>Divide...</h3>
Divides the image or selection by the specified real constant. Except for 32-bit (float) images,
attempts to divide by zero are ignored. With 32-bit images, dividing by zero results in
either <i>NaN</i> (0/0) or <i>Infinity</i>.

<h3>AND...</h3>
Does a bitwise AND of the image and the specified binary constant.

<h3>OR...</h3>
Does a bitwise OR of the image and the specified binary constant.

<h3>XOR...</h3>
Does a bitwise XOR of the image and the specified binary constant.

<h3>Min...</h3>
Pixels in the image with a value less than the specified constant are replaced by the constant.

<h3>Max...</h3>
Pixels in the image with a value greater than the specified constant are replaced by the constant.

<h3>Gamma...</h3>
Applies the function <i>f(p) = (p/255)^gamma*255</i>
to each pixel (<i>p</i>) in the image or selection, where 0.1 &lt;= <i>gamma</i>
 &lt;= 5.0. For RGB images, this function is applied to all three color 
channels. For 16-bit images, the image min and max are used for scaling 
instead of 255.

<h3>Set...</h3>
Fills the image or selection with the specified value.

<h3>Log...</h3>
For 8-bit images, applies the function <i>f(p) = log(p) * 255/log(255)</i>
to each pixel (<i>p</i>) in the image or selection. For RGB images, 
this function is applied to all three color channels. For 16-bit images, 
the image min and max are used for scaling instead of 255. For float images,
no scaling is done. To calculate log10 of the image, multiply the result 
of this operation by 0.4343 (1/log(10).

<h3>Reciprocal</h3>
Generates the reciprocal  of the active image or selection. Only works with 32-bit float images.

<h3>NaN Background</h3>
Sets non-thresholded pixels in 32-bit float images to the NaN (Not a Number) value. 
For float images, the "Apply" option in <i>Image&gt;Adjust Threshold</i> runs this command.
Pixels with a value of Float.NaN (0f/0f), Float.POSITIVE_INFINITY (1f/0f) or 
Float.NEGATIVE_INFINITY (-1f/0f) are ignored when making measurements on 32-bit float images.

<h3>Abs</h3>
Generates the absolute value of the active image or selection. Only works with 32-bit float images.

<a name="math-macro"></a>
<h3>Macro (Expression Evaluator)</h3>
This command performs image arithmetic using a user-specified expression.
It can be used to create fully-synthetic images or to perform precise pixel manipulations on
existing images or stacks.  The
<a href="https://imagej.nih.gov/ij/macros/examples/MathMacroDemo.txt">MathMacroDemo</a>
macro, written by Tiago Ferreira, demonstrates how to use it.

<p></p><center><img src="Process%20Menu_files/math-macro.png" alt="dialog" width="402" height="166"></center><p>

</p></blockquote>


<a name="fft"></a>
<h2>FFT Submenu</h2>
The commands in this submenu support frequency domain display, editing and processing. 
They are based on an implementation of the 2D Fast Hartley Transform (FHT) contributed 
by Arlo Reeves, the author of the
<a href="http://rsb.info.nih.gov/ij/download/docs/ImageFFT/">ImageFFT</a> spinoff of NIH Image.
For 3D FHTs, check out Bob Dougherty's
<a href="http://www.optinav.com/FHT3D.htm">3D Fast Hartley Transform</a>
plugin.

<blockquote>

<h3>FFT</h3>
 Computes the Fourier transform and displays the power spectrum. The 
 frequency domain image is stored as 32-bit float FHT attached to the 8-bit 
 image that displays the power spectrum. Commands in this submenu, such as <i>Inverse FFT</i>,
 operate on the 32-bit FHT, not on the 8-bit power spectrum. 
 All other ImageJ commands only "see" the power spectrum.
 <p>
 If the mouse is over an active frequency domain (FFT) window, its location 
 is displayed in polar coordinates. The angle is expressed in degrees, 
 while the radius is expressed in pixels per cycle (p/c).  
 The radius is expressed
 in [units] per cycle (e.g. mm/c) if the spatial scale of the image was 
 defined using <i>Analyze&gt;Set Scale</i>. With v1.39b or later,
 the polar coordinates of point selections are recorded by <i>Analyze&gt;Measure</i>.
 An <a href="https://imagej.nih.gov/ij/docs/examples/tem/">example</a> is available.
 
</p><h3>Inverse FFT</h3>
 Computes the inverse Fourier transform. You can filter or mask spots on the transformed 
 (frequency domain) image and do an inverse transform to produce an image which only 
 contains the frequencies selected or which suppresses the frequencies selected. 
 Use ImageJ's selection tools and fill/clear commands to draw black or white areas that mask 
 portions of the transformed image. Black areas (pixel value=0) cause the corresponding 
 frequences to be filtered (removed) and white areas (pixel value=255) cause the
 corresponding frequences to be passed. It is not, however, possible to both filter and 
 pass during the same inverse transform.
 <p>
 Note that areas to be filtered in the frequency domain image must be zero filled
 and areas to be passed must be filled with 255. You can varify that this is the case by moving the cursor
 over a filled area and observing that the values displayed in the status bar are either 0 or 255.
 </p><p>
 This example illustrates how to create masks that remove or pass the low frequencies
of an image.

</p><p></p><center><img src="Process%20Menu_files/fft.jpg" alt="fft example" width="641" height="172"></center><p>

With off-center selections, the same spatial frequency appears twice in 
the power spectrum,
at points opposite from the center. With ImageJ 1.41k and later, it is 
sufficient to fill/clear only one of
these. In the following example (courtesy of Arlo Reeves), the cleared 
selections in the upper half of the power spectrum have been 
automatically
mirrored to the lower half, as shown in the power spectrum of the 
filtered image.

</p><p></p><center><img src="Process%20Menu_files/abe.jpg" alt="fft example" width="606" height="174"></center><p>

 The image used in this
example is available at
<a href="http://rsb.info.nih.gov/ij/images/abe.tif">rsb.info.nih.gov/ij/images/abe.tif</a>.
There is also an
<a href="https://imagej.nih.gov/ij/docs/examples/FFT">example</a>
that demonstrates how to remove noise from images generated by a laser scanning confocal microscope.

</p><h3>Redisplay Power Spectrum</h3>
Recomputes the power spectrum from the frequency domain image (32-bit FHT). 
This command allows you to start over if you mess up while editing the 8-bit power spectrum 
image.

<a name="fft-options"></a>
<h3>FFT Options...</h3>
Displays the FFT Options dialog box.

<p></p><center><img src="Process%20Menu_files/fft-options.gif" alt="dialog" width="292" height="214"></center><p>

</p><ul>
	<li> 	<i>Display</i> - These are checkboxes that specify which image(s) are created by the FFT command:
	<ul>
	<li> 	<i>FFT Window </i>is the standard output. It consists of an 8-bit
 image of the power spectrum and the actual data, which remain invisible
 for the user. The power spectrum image is displayed with logarithmic 
scaling, enhancing the visibility of components that are weakly visible.
 The actual data are used for the Inverse FFT command.
	</li><li> 	<i>Raw Power Spectrum</i> is the power spectrum without logarithmic scaling.
	</li><li> 	<i>Fast Hartley Transform</i> is the internal format used by the command, which is based on a Hartley transform rather than Fourier transform.
	</li><li> 	<i>Complex Fourier Transform</i> is a stack with two slices for the real and imaginary parts of the FFT.
	</li></ul>
	</li><li> 	Check <i>Do Forward Transform</i> and the current image is transformed immediately 
	when closing the FFT Options dialog.
</li></ul>


<a name="fft-bandpass"></a>
<h3>Bandpass Filter..</h3>
This is a built in version of Joachim Walter's
<a href="http://rsb.info.nih.gov/ij/plugins/fft-filter.html">FFT Filter</a> plugin.
It removes high spatial frequencies (blurring the image) and low spatial
frequencies (similar to subtracting a blurred image). It can also 
suppress horizontal or vertical stripes that were created by scanning 
an image line by line. 

<p></p><center><img src="Process%20Menu_files/fft-bandpass.gif" alt="dialog" width="357" height="264"></center><p>

</p><ul>
    <li> <i>Filter Large Structures Down to</i> - Smooth variations of the image with
    typical sizes of bright or dark patches larger than this value are suppressed (background).
	<p>
    </p></li><li> <i>Filter Small Structures Up to</i> - Determines the amount of smoothing. Objects
    in the image smaller than this size are strongly attanuated. Note that these values 
    are both half the spatial frequencies of the actual cutoff. The cutoff is very soft, 
    so the bandpass will noticeably attenuate even spatial frequencies in the center 
    of the bandpass unless the difference of the two values is large (say, more than 
    a factor of 5 or so).
	<p>
    </p></li><li> <i>Suppress Stripes</i> - Select whether to eliminate horizontal or vertical stripes.
    Removal of horizontal stripes is similar to subtracting an image that is only blurred
    in the horizontal direction from the original.
	<p>
    </p></li><li> <i>Tolerance of Direction</i> - This is for <i>Suppress Stripes</i>; higher values remove 
    shorter stripes and/or stripes that are running under an angle with respect to the 
    horizontal (vertical) direction.
	<p>
    </p></li><li> <i>Autoscale After Filtering</i> puts the lowest intensity to 0 and the highest
    intensity to 255, preserving all intensities.
	<p>
    </p></li><li> <i>Saturate</i> allows some intensities to go into saturation, and produces a 
    better visual contrast. Saturate only has an effect when <i>Autoscale</i> is enabled.
	<p>
    </p></li><li> <i>Display Filter</i> shows the filter generated. Note that this disables <i>Undo</i> 
    of the filter operation on the original image.
</li></ul>

The Bandpass Filter uses a special algorithm to reduce edge artifacts (before the Fourier
transform, the image is extended in size by attaching mirrored copies of image parts
outside the original image, thus no jumps occur at the edges). 


<a name="fft-filter"></a>
<h3>Custom Filter..</h3>
This command does fourier space filtering of the active using a user-supplied image as the filter.

This command does Fourier space filtering of the active image using a user-supplied image as the filter.
This image will be converted to 8-bits. For pixels that have a value of 0, the corresponding spatial
frequences will be blocked. Pixel with values of 255 should be used for passing the respective
spatial frequencies without attenuation. Note that the filter should be symmetric with respect to
inversion of the center: Points that are opposite of the center point (defined as x=width/2, y=height/2) should
have the same value. Otherwise, artifacts can occur.
 <p>
 For
some examples, see the
<a href="http://rsb.info.nih.gov/ij/macros/FFTCustomFilterDemo.txt">FFTCustomFilterDemo</a> and
<a href="http://rsb.info.nih.gov/ij/macros/FFTRemoveStreaks.txt">FFTRemoveStreaks</a> macros.

<a name="fft-math"></a>
</p><h3>FD Math..</h3>
This command correlates, convolves or deconvolves two images. It does this by
converting the images to the frequency domain, performing conjugate multiplication, multiplication
or division, then converting the result back to the space domain. These three operations 
in the frequency domain are equivalent to correlation, convolution and deconvolution in the space domain.
Refer to the 
<a href="http://rsb.info.nih.gov/ij/macros/DeconvolutionDemo.txt">DeconvolutionDemo</a> and
<a href="http://rsb.info.nih.gov/ij/macros/MotionBlurRemoval.txt">MotionBlurRemoval</a>
macros for an examples.

</blockquote>


<a name="filters"></a>

<h2>Filters Submenu</h2>
This submenu contains miscellaneous filters and plugin filters that have been 
installed by the <i>Plugins&gt;Utilities&gt;Install Plugin</i> command. 
For more information, refer to the Hypermedia Image Processing Reference at
<a href="http://www.dai.ed.ac.uk/HIPR2/">http://www.dai.ed.ac.uk/HIPR2/</a>. 
Click on <a href="http://www.dai.ed.ac.uk/HIPR2/index.htm">Index</a>
and look up the keywords convolution, Gaussian, median, mean, erode, 
dilate and unsharp.


<blockquote>

<h3>Convolve...</h3>

Does spatial convolution using a kernel entered into a text area. A  
kernel is a matrix whose center corresponds to the source pixel and 
the other elements correspond to neighboring pixels. The destination 
pixel is calculated by multiplying each source pixel by its corresponding 
kernel coefficient and adding the results. If needed, the input image is
effectively extended by duplicating edge pixels outward.
There is no arbitrary 
limit to the size of the kernel but it must be square and have an odd width. 

<p></p><center><img src="Process%20Menu_files/convolver.gif" alt="[convolver]"></center><p>

Rows in the text area must all have the same number of coefficients, the rows must be 
terminated with a carriage return, and the coefficients must be separated by one or more 
spaces. Kernels can be pasted into the text area using the ctrl+v keyboard shortcut. 

Checking <i>Normalize Kernel</i> causes each coefficient to be divided by the sum of the 
coefficients, preserving image brightness. 
</p><p>
The kernel shown is a 9 x 9 "Mexican hat", which does both smoothing and edge 
detection in one operation. Note that kernels can be saved as a text file by clicking on the
"Save" button, displayed as an image using <i>File&gt;Import&gt;Text Image</i>,
scaled to a reasonable size using <i>Image&gt;Adjust&gt;Size</i>
and plotted using <i>Analyze&gt;Surface Plot</i>.
</p><p>
The <a href="http://rsb.info.nih.gov/ij/macros/examples/ConvolutionDemo.txt">ConvolutionDemo</a>
macro demonstrates how to use this command in a macro.

<a name="blur"></a>
</p><h3>Gaussian Blur...</h3>
This filter uses convolution with a Gaussian function for smoothing.
<i>Sigma</i> is the radius of decay to exp(-0.5) ~ 61%, i.e. the standard
deviation sigma of the Gaussian (this is the same as in Photoshop, but
different from earlier versions of ImageJ, where a value
2.5 times as much had to be entered.
<p>
Like all ImageJ convolution operations, it assumes that out-of-image
pixels have a value equal to the nearest edge pixel. This gives higher
weight to edge pixels than pixels inside the image, and higher weight
to corner pixels than non-corner pixels at the edge. Thus, when smoothing
with very high blur radius, the output will be dominated by the edge
pixels and especially the corner pixels (in the extreme case, with
a blur radius of e.g. 1e20, the image will be raplaced by the average
of the four corner pixels).
</p><p>
For increased speed, except for small blur radii, the lines (rows or
columns of the image) are downscaled before convolution and upscaled
to their original length thereafter.
 
</p><h3>Median...</h3>
Reduces noise in the active image by replacing each pixel with the median of the 
neighboring pixel values.

<h3>Mean...</h3>
Smooths the current image by replacing each pixel with the neighborhood mean. 
The size of the neighborhood is specified by entering its radius in a dialog box.

<h3>Minimum...</h3>
This filter does grayscale erosion by replacing each pixel in the image with 
the smallest pixel value in that pixel's neighborhood.

<h3>Maximum...</h3>
This filter does grayscale dilation by replacing each pixel in the image with 
the largest pixel value in that pixel's neighborhood.

<h3>Unsharp Mask...</h3>
Unsharp masking subtracts a blurred copy of the image and rescales the image
to obtain the same contrast of large (low-frequency) structures as in the
input image. This is equivalent to adding a high-pass filtered image and
thus sharpens the image.
<i>Radius</i> is the standard deviation (blur radius) of the Gaussian blur
that is subtracted.
<i>Mask Weight</i> determines the strength of filtering, whereby <i>Mask Weight</i>=1
 would be an infinite weight of the high-pass filtered image that is added.

<h3>Variance...</h3>
Heighlights edges in the image by replacing each pixel with the neighborhood variance. 

<h3>Show Circular Masks</h3>
Generates a stack containing examples of the circular masks used by the 
<i>Median</i>, <i>Mean</i>, <i>Minimum</i>, <i>Maximum</i> and <i>Variance</i> 
filters for various neighborhood sizes.

</blockquote>


<a name="calculator"></a>

<h3>Image Calculator...</h3>
Performs arithmetic and logical operations between two images selected from popup menus. 
<i>Image1</i> or both <i>Image1</i> and <i>Image2</i> can be stacks. 
If both are stacks, they must have the same number of slices. 
<i>Image1</i> and <i>Image2</i> must be the same data type but they 
do not have to be the same size.

<p></p><center><img src="Process%20Menu_files/calculator.jpg" alt="[Image Calculator]" width="280" height="282"></center><p>

You can select one of 12 operators from the <i>Operation:</i> popup menu. 
Check <i>Create New Window</i> and  a new image or stack will be created 
to hold the result.  Otherwise, the result of the operation replaces some or all of <i>Image1</i>. 
Check "32-bit Result" and the source images will be converted to 32-bit floating
point before the specified operation is performed.
</p><p>
With 32-bit (float) images, pixels resulting from division by 
zero are set to <i>Infinity</i>, or to <i>NaN</i> (Not a Number) if a zero pixel is divided by zero.
The divide-by-zero value can be redefined in <i>Edit&gt;Options&gt;Misc</i>.
 
</p><p> 
 
</p><center>
<table cellpadding="5" border="1">
<tbody><tr> <td> Add </td> <td> img1 = img1+img2 </td> </tr>
<tr> <td> Subtract </td> <td> img1 = img1-img2 </td> </tr>
<tr> <td> Multiply </td> <td> img1 = img1*img2</td> </tr>
<tr> <td> Divide </td> <td> img1 = img1/img2 </td> </tr>
<tr> <td> AND </td> <td> img1= img1 AND img2 </td> </tr>
<tr> <td> OR </td> <td> img1 = img1 OR img2 </td> </tr>
<tr> <td> XOR </td> <td> img1 = img1 XOR img2 </td> </tr>
<tr> <td> Min </td> <td> img1 = min(img1,img2) </td> </tr>
<tr> <td> Max </td> <td> img1 = max(img1,img2) </td> </tr>
<tr> <td> Average </td> <td> img1 = (img1+img2)/2 </td> </tr>
<tr> <td> Difference </td> <td> img1 = |img1-img2|</td> </tr>
<tr> <td> Copy </td> <td> img1 =  img2 </td> </tr>
</tbody></table>
</center>
<p>

In these examples, the source and destination have inverted LUTs so zero
 pixels are white. Operations on images with non-inverted LUTs, and RGB 
images, will not produce the same results.

</p><p></p><center><img src="Process%20Menu_files/calculations.gif" alt="[calculations]"></center><p>

<a name="background"></a>

</p><h3>Subtract Background...</h3>

Removes smooth continuous backgrounds from gels and other images. Based on the "rolling ball" algorithm 
described in Stanley Sternberg's article, "Biomedical Image Processing", IEEE Computer, January 1983. 
Imagine a 3D surface with the pixel values of the image being the height, then a ball rolling over the back 
side of the surface creates the background. The current algorithm (since v1.39f) uses an approximation
of a paraboloid of rotation instead of a ball.

<p></p><center><img src="Process%20Menu_files/subtract-background-dialog.jpg" alt="[Dialog]" width="324" height="206"></center><p>

The <i>Rolling Ball Radius</i> is the radius of curvature of the paraboloid. As a rule of thumb,
for 8-bit or RGB images it should be at least as large as the radius of the largest object in the 
image that is not part of the background. Larger values will also work unless the background 
of the image is too uneven. For 16-bit and 32-bit images with pixel value ranges different from 0-255, 
the radius should be inversely proportional to the pixel value range. 
For example, typical values of the radius are around 0.2 to 5 for 16-bit images (pixel values 0-65535).
</p><p>
The <i>Light Background</i> option allows the processing of images with bright background and dark objects.
</p><p>
With the <i>Create Background</i> option, the output is not the image with the background subtracted but
rather the background itself. This option is useful for examining the background created (in conjunction 
with the <i>Preview</i> option). <i>Create Background</i> can be also used for custom background
subtraction algorithms where the image is duplicated and filtered (e.g. removing "holes" in the background) 
before creating the background and finally subtracting it with <i>Process&gt;Image Calculator</i>.
</p><p>
For calculating the background ("rolling the ball"), images are
maximum-filtered (3x3 pixels) to remove outliers such as dust
and then smoothed to reduce noise (average over 3x3 pixels).
With <i>Disable Smoothing</i>, the unmodified image data are used for creating the background.
Check this option to make sure that the image data after subtraction will 
never be below the background.
	
</p><p></p><center><img src="Process%20Menu_files/subtract-background-example.jpg" alt="[Example]" width="609" height="296"></center><p>


<a name="repeat">

</a></p><h3><a name="repeat">Repeat Command</a></h3><a name="repeat">

Reruns the previous command. The Undo and Open commands are skipped. For a shortcut, type shift-R.

</a><p></p></blockquote>

<p class="navbar"> <a href="https://imagej.nih.gov/ij/docs/menus/process.html">top</a> | <a href="https://imagej.nih.gov/ij/index.html">home</a> | <a href="https://imagej.nih.gov/ij/docs/index.html">contents</a> | <a href="https://imagej.nih.gov/ij/docs/menus/image.html">previous</a> | <a href="https://imagej.nih.gov/ij/docs/menus/analyze.html">next</a></p>

</body></html>